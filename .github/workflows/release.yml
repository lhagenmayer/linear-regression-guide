name: Release & Publish

on:
  push:
    tags: [ 'v*' ]  # Only trigger on version tags
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type (patch, minor, major, prerelease)'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
          - prerelease
      prerelease_identifier:
        description: 'Prerelease identifier (alpha, beta, rc)'
        required: false
        default: 'beta'
        type: choice
        options:
          - alpha
          - beta
          - rc
      custom_version:
        description: 'Custom version (leave empty for auto-versioning)'
        required: false
        type: string
      create_github_release:
        description: 'Create GitHub release'
        required: false
        default: true
        type: boolean
      publish_to_pypi:
        description: 'Publish to PyPI (if configured)'
        required: false
        default: false
        type: boolean

env:
  PYTHONUNBUFFERED: 1

jobs:
  # ====================================================================
  # RELEASE PREPARATION & VALIDATION
  # ====================================================================

  prepare-release:
    name: Prepare Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      release_notes: ${{ steps.release-notes.outputs.notes }}
      should_release: ${{ steps.check-release.outputs.should_release }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.12"

    - name: Install release tools
      run: |
        python -m pip install --upgrade pip
        pip install semantic-release python-semantic-release commitizen

    # ====================================================================
    # VERSION DETERMINATION
    # ====================================================================

    - name: Determine version
      id: version
      run: |
        if [[ "${{ github.event.inputs.custom_version }}" != "" ]]; then
          # Use custom version
          VERSION="${{ github.event.inputs.custom_version }}"
          echo "Using custom version: $VERSION"
        elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          # Manual release with specified type
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.1.0")
          CURRENT_VERSION=${CURRENT_VERSION#v}  # Remove 'v' prefix

          # Simple version bumping logic
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}

          case $RELEASE_TYPE in
            "patch")
              PATCH=$((PATCH + 1))
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "prerelease")
              PRERELEASE_ID="${{ github.event.inputs.prerelease_identifier }}"
              PATCH=$((PATCH + 1))
              VERSION="${MAJOR}.${MINOR}.${PATCH}-${PRERELEASE_ID}.1"
              ;;
          esac

          if [[ "$RELEASE_TYPE" != "prerelease" ]]; then
            VERSION="${MAJOR}.${MINOR}.${PATCH}"
          fi

          echo "Calculated version: $VERSION (type: $RELEASE_TYPE)"
        else
          # Automatic versioning based on conventional commits
          # This is a simplified version - in practice you'd use semantic-release
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.1.0")
          LATEST_TAG=${LATEST_TAG#v}

          # Check for breaking changes, features, or fixes since last tag
          BREAKING=$(git log --oneline "${LATEST_TAG}..HEAD" | grep -E "BREAKING|!" | wc -l)
          FEATURES=$(git log --oneline "${LATEST_TAG}..HEAD" | grep -E "feat:" | wc -l)
          FIXES=$(git log --oneline "${LATEST_TAG}..HEAD" | grep -E "fix:" | wc -l)

          if [[ $BREAKING -gt 0 ]]; then
            # Major version bump
            IFS='.' read -ra PARTS <<< "$LATEST_TAG"
            VERSION="$((PARTS[0] + 1)).0.0"
          elif [[ $FEATURES -gt 0 ]]; then
            # Minor version bump
            IFS='.' read -ra PARTS <<< "$LATEST_TAG"
            VERSION="${PARTS[0]}.$((PARTS[1] + 1)).0"
          elif [[ $FIXES -gt 0 ]]; then
            # Patch version bump
            IFS='.' read -ra PARTS <<< "$LATEST_TAG"
            VERSION="${PARTS[0]}.${PARTS[1]}.$((PARTS[2] + 1))"
          else
            # No changes requiring version bump
            echo "No version bump needed - no conventional commits found"
            echo "should_release=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Auto-calculated version: $VERSION"
        fi

        TAG="v${VERSION}"
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        echo "should_release=true" >> $GITHUB_OUTPUT

    - name: Check if release should proceed
      id: check-release
      run: |
        # Additional checks before proceeding with release
        if [[ "${{ steps.version.outputs.should_release }}" == "false" ]]; then
          echo "should_release=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Check if tag already exists
        if git tag -l | grep -q "^${{ steps.version.outputs.tag }}$"; then
          echo "Tag ${{ steps.version.outputs.tag }} already exists"
          echo "should_release=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Check if all required tests passed (this would check against other workflows)
        # For now, assume we proceed
        echo "should_release=true" >> $GITHUB_OUTPUT

    - name: Generate release notes
      id: release-notes
      if: steps.check-release.outputs.should_release == 'true'
      run: |
        # Generate release notes from conventional commits
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

        if [[ -n "$PREVIOUS_TAG" ]]; then
          # Get commits since last tag
          COMMITS=$(git log --oneline --pretty=format:"%s" "${PREVIOUS_TAG}..HEAD" 2>/dev/null || echo "")
        else
          # Get all commits for initial release
          COMMITS=$(git log --oneline --pretty=format:"%s" | head -20)
        fi

        # Categorize commits
        BREAKING=$(echo "$COMMITS" | grep -E "BREAKING|!" | wc -l)
        FEATURES=$(echo "$COMMITS" | grep -E "^feat:" | wc -l)
        FIXES=$(echo "$COMMITS" | grep -E "^fix:" | wc -l)
        DOCS=$(echo "$COMMITS" | grep -E "^docs:" | wc -l)
        STYLE=$(echo "$COMMITS" | grep -E "^style:" | wc -l)
        REFACTOR=$(echo "$COMMITS" | grep -E "^refactor:" | wc -l)
        TEST=$(echo "$COMMITS" | grep -E "^test:" | wc -l)
        CHORE=$(echo "$COMMITS" | grep -E "^chore:" | wc -l)

        # Generate release notes
        NOTES="## What's Changed

"

        if [[ $BREAKING -gt 0 ]]; then
          NOTES+="$BREAKING breaking changes
"
        fi

        if [[ $FEATURES -gt 0 ]]; then
          NOTES+="### ‚ú® New Features
"
          echo "$COMMITS" | grep "^feat:" | head -10 | while read -r line; do
            NOTES+="- $line
"
          done
          if [[ $FEATURES -gt 10 ]]; then
            NOTES+="... and $((FEATURES - 10)) more features
"
          fi
          NOTES+="
"
        fi

        if [[ $FIXES -gt 0 ]]; then
          NOTES+="### üêõ Bug Fixes
"
          echo "$COMMITS" | grep "^fix:" | head -10 | while read -r line; do
            NOTES+="- $line
"
          done
          if [[ $FIXES -gt 10 ]]; then
            NOTES+="... and $((FIXES - 10)) more fixes
"
          fi
          NOTES+="
"
        fi

        if [[ $DOCS -gt 0 ]] || [[ $STYLE -gt 0 ]] || [[ $REFACTOR -gt 0 ]] || [[ $TEST -gt 0 ]] || [[ $CHORE -gt 0 ]]; then
          NOTES+="### üîß Other Changes
"
          if [[ $DOCS -gt 0 ]]; then NOTES+="- $DOCS documentation updates
"; fi
          if [[ $STYLE -gt 0 ]]; then NOTES+="- $STYLE code style improvements
"; fi
          if [[ $REFACTOR -gt 0 ]]; then NOTES+="- $REFACTOR code refactoring
"; fi
          if [[ $TEST -gt 0 ]]; then NOTES+="- $TEST testing improvements
"; fi
          if [[ $CHORE -gt 0 ]]; then NOTES+="- $CHORE maintenance tasks
"; fi
          NOTES+="
"
        fi

        NOTES+="**Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...${{ steps.version.outputs.tag }}"

        echo "notes<<EOF" >> $GITHUB_OUTPUT
        echo "$NOTES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

  # ====================================================================
  # QUALITY GATES - ENSURE RELEASE READINESS
  # ====================================================================

  quality-gate:
    name: Quality Gate Check
    runs-on: ubuntu-latest
    needs: prepare-release
    if: needs.prepare-release.outputs.should_release == 'true'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.12"

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt -r requirements-dev.txt

    - name: Run quality checks
      run: |
        echo "üîç Running pre-release quality checks..."

        # Code formatting
        if ! python -m black --check --diff src/ tests/ run.py >/dev/null 2>&1; then
          echo "‚ùå Code formatting issues found"
          exit 1
        fi

        # Linting
        if ! python -m flake8 src/ tests/ run.py >/dev/null 2>&1; then
          echo "‚ùå Linting issues found"
          exit 1
        fi

        # Type checking
        if ! python -m mypy src/ >/dev/null 2>&1; then
          echo "‚ùå Type checking issues found"
          exit 1
        fi

        # Tests
        if ! python -m pytest tests/ -q >/dev/null 2>&1; then
          echo "‚ùå Test failures found"
          exit 1
        fi

        echo "‚úÖ All quality checks passed"

  # ====================================================================
  # BUILD & PACKAGE
  # ====================================================================

  build-package:
    name: Build & Package
    runs-on: ubuntu-latest
    needs: [prepare-release, quality-gate]
    if: needs.prepare-release.outputs.should_release == 'true'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.12"

    - name: Install build dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build twine

    - name: Update version in pyproject.toml
      run: |
        VERSION="${{ needs.prepare-release.outputs.version }}"
        echo "Updating version to $VERSION"

        # Update pyproject.toml version
        sed -i "s/version = \"[^\"]*\"/version = \"$VERSION\"/" pyproject.toml

        # Update __init__.py if it exists
        if [[ -f "src/__init__.py" ]]; then
          sed -i "s/__version__ = \"[^\"]*\"/__version__ = \"$VERSION\"/" src/__init__.py
        fi

    - name: Build package
      run: |
        python -m build

    - name: Validate package
      run: |
        # Check that the package can be installed
        pip install --dry-run dist/*.whl

        # List package contents
        echo "Package contents:"
        python -c "
        import zipfile
        import glob
        for whl_file in glob.glob('dist/*.whl'):
            with zipfile.ZipFile(whl_file) as zf:
                files = [f for f in zf.namelist() if not f.endswith('/')]
                print(f'{whl_file}: {len(files)} files')
                for f in files[:10]:  # Show first 10 files
                    print(f'  {f}')
        "

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: release-artifacts-${{ needs.prepare-release.outputs.version }}
        path: |
          dist/
          build/

  # ====================================================================
  # PUBLISH TO PYPI (OPTIONAL)
  # ====================================================================

  publish-pypi:
    name: Publish to PyPI
    runs-on: ubuntu-latest
    needs: [prepare-release, build-package]
    if: needs.prepare-release.outputs.should_release == 'true' && github.event.inputs.publish_to_pypi == true
    environment: release

    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: release-artifacts-${{ needs.prepare-release.outputs.version }}
        path: dist/

    - name: Publish to PyPI
      env:
        TWINE_USERNAME: ${{ secrets.PYPI_USERNAME }}
        TWINE_PASSWORD: ${{ secrets.PYPI_PASSWORD }}
      run: |
        python -m twine upload dist/*

  # ====================================================================
  # CREATE GITHUB RELEASE
  # ====================================================================

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [prepare-release, quality-gate, build-package]
    if: needs.prepare-release.outputs.should_release == 'true' && (github.event.inputs.create_github_release == true || github.event_name != 'workflow_dispatch')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: release-artifacts-${{ needs.prepare-release.outputs.version }}
        path: dist/

    - name: Create GitHub release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ needs.prepare-release.outputs.tag }}
        release_name: Release ${{ needs.prepare-release.outputs.version }}
        body: ${{ needs.prepare-release.outputs.release_notes }}
        draft: false
        prerelease: ${{ contains(needs.prepare-release.outputs.version, '-') }}

    - name: Create tag
      run: |
        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"
        git tag ${{ needs.prepare-release.outputs.tag }}
        git push origin ${{ needs.prepare-release.outputs.tag }}

  # ====================================================================
  # POST-RELEASE CLEANUP & NOTIFICATION
  # ====================================================================

  post-release:
    name: Post-Release Tasks
    runs-on: ubuntu-latest
    needs: [create-release, publish-pypi]
    if: always()

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Update version for development
      if: needs.create-release.result == 'success'
      run: |
        # Bump to next development version
        VERSION="${{ needs.prepare-release.outputs.version }}"
        IFS='.' read -ra PARTS <<< "$VERSION"
        NEXT_PATCH=$((PARTS[2] + 1))
        DEV_VERSION="${PARTS[0]}.${PARTS[1]}.$NEXT_PATCH-dev"

        echo "Next development version: $DEV_VERSION"

        # Update pyproject.toml with dev version
        sed -i "s/version = \"${VERSION}\"/version = \"${DEV_VERSION}\"/" pyproject.toml

        # Commit development version bump
        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"
        git add pyproject.toml
        git commit -m "chore: bump to development version $DEV_VERSION" || true
        git push origin HEAD || true

    - name: Generate release summary
      run: |
        echo "# üöÄ Release Summary" > release-summary.md
        echo "" >> release-summary.md
        echo "## Release Details" >> release-summary.md
        echo "- **Version**: ${{ needs.prepare-release.outputs.version }}" >> release-summary.md
        echo "- **Tag**: ${{ needs.prepare-release.outputs.tag }}" >> release-summary.md
        echo "- **Released**: $(date)" >> release-summary.md
        echo "- **Repository**: ${{ github.repository }}" >> release-summary.md
        echo "" >> release-summary.md

        echo "## Release Status" >> release-summary.md
        echo "- ‚úÖ **GitHub Release**: ${{ needs.create-release.result }}" >> release-summary.md
        echo "- üì¶ **PyPI Publish**: ${{ needs.publish-pypi.result }}" >> release-summary.md
        echo "- üîß **Build**: ${{ needs.build-package.result }}" >> release-summary.md
        echo "" >> release-summary.md

        echo "## What's Next" >> release-summary.md
        echo "1. Monitor the deployment" >> release-summary.md
        echo "2. Update documentation if needed" >> release-summary.md
        echo "3. Communicate release to users" >> release-summary.md
        echo "4. Plan next release cycle" >> release-summary.md

    - name: Upload release summary
      uses: actions/upload-artifact@v4
      with:
        name: release-summary
        path: release-summary.md

    - name: Release completion notification
      if: always()
      run: |
        if [[ "${{ needs.create-release.result }}" == "success" ]]; then
          echo "üéâ Release ${{ needs.prepare-release.outputs.version }} completed successfully!"
          echo ""
          echo "üìã Summary:"
          echo "  ‚Ä¢ GitHub Release: ‚úÖ Created"
          echo "  ‚Ä¢ PyPI Publish: ${{ needs.publish-pypi.result == 'success' && '‚úÖ Published' || '‚ùå Not requested' }}"
          echo "  ‚Ä¢ Version: ${{ needs.prepare-release.outputs.version }}"
          echo "  ‚Ä¢ Tag: ${{ needs.prepare-release.outputs.tag }}"
          echo ""
          echo "üîó Release URL: https://github.com/${{ github.repository }}/releases/tag/${{ needs.prepare-release.outputs.tag }}"
        else
          echo "‚ö†Ô∏è Release process encountered issues. Check the logs above."
        fi