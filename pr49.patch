From 4da78d7783e4eb96db9b383e47f13d8ea9657ec7 Mon Sep 17 00:00:00 2001
From: Cursor Agent <cursoragent@cursor.com>
Date: Thu, 8 Jan 2026 10:01:57 +0000
Subject: [PATCH] feat: Add educational datasets for simple vs multiple
 regression

Co-authored-by: l.hagenmayer <l.hagenmayer@gmail.com>
---
 src/api/endpoints.py     |  54 ++++++++-
 src/data/content.py      |  93 ++++++++++++----
 src/pipeline/get_data.py | 229 ++++++++++++++++++++++++++++++++++++++-
 3 files changed, 350 insertions(+), 26 deletions(-)

diff --git a/src/api/endpoints.py b/src/api/endpoints.py
index 8aa1254..5f13c3c 100644
--- a/src/api/endpoints.py
+++ b/src/api/endpoints.py
@@ -168,6 +168,12 @@ def get_datasets(self) -> Dict[str, Any]:
         """
         List available datasets.
         
+        All datasets are available for BOTH simple and multiple regression.
+        This is intentional for educational purposes:
+        - Simple regression shows larger error term (omitted variable bias)
+        - Multiple regression shows improved RÂ² when adding relevant predictors
+        - Students can directly compare and understand "AHH, that's why!"
+        
         Returns:
             Dictionary of available datasets
         """
@@ -178,20 +184,39 @@ def get_datasets(self) -> Dict[str, Any]:
                     {
                         "id": "electronics",
                         "name": "Elektronikmarkt",
-                        "description": "VerkaufsflÃ¤che vs Umsatz",
+                        "description": "VerkaufsflÃ¤che â†’ Umsatz",
                         "icon": "ðŸª",
+                        "hint": "âž¡ï¸ Multiple: +Marketingbudget",
                     },
                     {
                         "id": "advertising",
                         "name": "Werbestudie",
-                        "description": "Werbeausgaben vs Umsatz",
+                        "description": "Werbeausgaben â†’ Umsatz",
                         "icon": "ðŸ“¢",
+                        "hint": "âž¡ï¸ Multiple: +ProduktqualitÃ¤t",
                     },
                     {
                         "id": "temperature",
                         "name": "Eisverkauf",
-                        "description": "Temperatur vs Verkauf",
+                        "description": "Temperatur â†’ Verkauf",
                         "icon": "ðŸ¦",
+                        "hint": "âž¡ï¸ Multiple: +Wochenende",
+                    },
+                    {
+                        "id": "cities",
+                        "name": "StÃ¤dtestudie (nur Preis)",
+                        "description": "Preis â†’ Umsatz âš ï¸ Omitted Variable!",
+                        "icon": "ðŸ™ï¸",
+                        "hint": "ðŸ’¡ Vergleiche mit Multipler Regression!",
+                        "educational": True,
+                    },
+                    {
+                        "id": "houses",
+                        "name": "Hauspreise (nur FlÃ¤che)",
+                        "description": "WohnflÃ¤che â†’ Preis âš ï¸ Omitted Variable!",
+                        "icon": "ðŸ ",
+                        "hint": "ðŸ’¡ Pool-Effekt fehlt! Wechsle zu Multiple.",
+                        "educational": True,
                     },
                 ],
                 "multiple": [
@@ -200,12 +225,35 @@ def get_datasets(self) -> Dict[str, Any]:
                         "name": "StÃ¤dtestudie",
                         "description": "Preis & Werbung â†’ Umsatz",
                         "icon": "ðŸ™ï¸",
+                        "hint": "â¬…ï¸ Simple: Nur Preis (grÃ¶ÃŸerer Fehler)",
                     },
                     {
                         "id": "houses",
                         "name": "Hauspreise",
                         "description": "FlÃ¤che & Pool â†’ Preis",
                         "icon": "ðŸ ",
+                        "hint": "â¬…ï¸ Simple: Nur FlÃ¤che (grÃ¶ÃŸerer Fehler)",
+                    },
+                    {
+                        "id": "electronics",
+                        "name": "Elektronikmarkt",
+                        "description": "FlÃ¤che & Marketing â†’ Umsatz",
+                        "icon": "ðŸª",
+                        "hint": "â¬…ï¸ Simple: Nur FlÃ¤che (grÃ¶ÃŸerer Fehler)",
+                    },
+                    {
+                        "id": "advertising",
+                        "name": "Werbestudie",
+                        "description": "Werbung & QualitÃ¤t â†’ Umsatz",
+                        "icon": "ðŸ“¢",
+                        "hint": "â¬…ï¸ Simple: Nur Werbung (grÃ¶ÃŸerer Fehler)",
+                    },
+                    {
+                        "id": "temperature",
+                        "name": "Eisverkauf",
+                        "description": "Temperatur & Wochenende â†’ Verkauf",
+                        "icon": "ðŸ¦",
+                        "hint": "â¬…ï¸ Simple: Nur Temperatur (grÃ¶ÃŸerer Fehler)",
                     },
                 ],
             },
diff --git a/src/data/content.py b/src/data/content.py
index 3b72b3f..fa065fc 100644
--- a/src/data/content.py
+++ b/src/data/content.py
@@ -17,7 +17,7 @@ def get_multiple_regression_formulas(dataset_choice_mult: str) -> Dict[str, str]
     Get LaTeX formulas for multiple regression based on dataset.
 
     Args:
-        dataset_choice_mult: The selected dataset
+        dataset_choice_mult: The selected dataset (can be emoji-style or simple id)
 
     Returns:
         Dictionary with 'general' and 'specific' LaTeX formulas
@@ -26,19 +26,28 @@ def get_multiple_regression_formulas(dataset_choice_mult: str) -> Dict[str, str]
         "general": r"y_i = \beta_0 + \beta_1 \cdot x_{1i} + \beta_2 \cdot x_{2i} + \cdots + \beta_K \cdot x_{Ki} + \varepsilon_i"
     }
 
-    if dataset_choice_mult == "ðŸ™ï¸ StÃ¤dte-Umsatzstudie (75 StÃ¤dte)":
+    # Normalize dataset name to handle both formats
+    dataset_lower = dataset_choice_mult.lower() if dataset_choice_mult else ""
+
+    if "stÃ¤dte" in dataset_lower or dataset_choice_mult == "cities":
         formulas["specific"] = r"\text{Umsatz}_i = \beta_0 + \beta_1 \cdot \text{Preis}_i + \beta_2 \cdot \text{Werbung}_i + \varepsilon_i"
         formulas["context"] = "Handelskette in 75 StÃ¤dten"
-    elif dataset_choice_mult == "ðŸ  HÃ¤userpreise mit Pool (1000 HÃ¤user)":
+    elif "hÃ¤user" in dataset_lower or "haus" in dataset_lower or dataset_choice_mult == "houses":
         formulas["specific"] = r"\text{Preis}_i = \beta_0 + \beta_1 \cdot \text{WohnflÃ¤che}_i + \beta_2 \cdot \text{Pool}_i + \varepsilon_i"
         formulas["context"] = "HausverkÃ¤ufe in UniversitÃ¤tsstadt"
-    elif dataset_choice_mult == "ðŸ‡¨ðŸ‡­ Schweizer Kantone (sozioÃ¶konomisch)":
+    elif "kantone" in dataset_lower or "schweizer" in dataset_lower:
         formulas["specific"] = r"\text{GDP}_i = \beta_0 + \beta_1 \cdot \text{Population Density}_i + \beta_2 \cdot \text{Foreign \%}_i + \beta_3 \cdot \text{Unemployment}_i + \varepsilon_i"
         formulas["context"] = "Schweizer Kantone SozioÃ¶konomie"
-    elif dataset_choice_mult == "ðŸŒ¤ï¸ Schweizer Wetterstationen":
+    elif "wetter" in dataset_lower:
         formulas["specific"] = r"\text{Temperature}_i = \beta_0 + \beta_1 \cdot \text{Altitude}_i + \beta_2 \cdot \text{Sunshine}_i + \beta_3 \cdot \text{Humidity}_i + \varepsilon_i"
         formulas["context"] = "Schweizer Klimastationen"
-    else:  # Elektronikmarkt
+    elif "werbe" in dataset_lower or dataset_choice_mult == "advertising":
+        formulas["specific"] = r"\text{Umsatz}_i = \beta_0 + \beta_1 \cdot \text{Werbung}_i + \beta_2 \cdot \text{QualitÃ¤t}_i + \varepsilon_i"
+        formulas["context"] = "Werbestudie mit QualitÃ¤tsfaktor"
+    elif "eis" in dataset_lower or "temperature" in dataset_lower or dataset_choice_mult == "temperature":
+        formulas["specific"] = r"\text{Verkauf}_i = \beta_0 + \beta_1 \cdot \text{Temperatur}_i + \beta_2 \cdot \text{Wochenende}_i + \varepsilon_i"
+        formulas["context"] = "Eisverkauf mit Wochenend-Effekt"
+    else:  # Elektronikmarkt (default)
         formulas["specific"] = r"\text{Umsatz}_i = \beta_0 + \beta_1 \cdot \text{FlÃ¤che}_i + \beta_2 \cdot \text{Marketing}_i + \varepsilon_i"
         formulas["context"] = "Elektronikmarkt-Kette"
 
@@ -48,24 +57,32 @@ def get_multiple_regression_formulas(dataset_choice_mult: str) -> Dict[str, str]
 def get_multiple_regression_descriptions(dataset_choice_mult: str) -> Dict[str, str]:
     """
     Get descriptions and context for multiple regression based on dataset.
+    
+    All datasets are available for multiple regression to allow comparison
+    with simple regression (educational: omitted variable bias).
     """
     descriptions = {}
+    
+    # Normalize dataset name to handle both formats
+    dataset_lower = dataset_choice_mult.lower() if dataset_choice_mult else ""
 
-    if dataset_choice_mult == "ðŸ™ï¸ StÃ¤dte-Umsatzstudie (75 StÃ¤dte)":
+    if "stÃ¤dte" in dataset_lower or dataset_choice_mult == "cities":
         descriptions["main"] = "Eine Handelskette untersucht in **75 StÃ¤dten** den Zusammenhang zwischen Produktpreis, Werbeausgaben und Umsatz."
         descriptions["variables"] = {
             "x1": "Produktpreis (in CHF)",
             "x2": "Werbeausgaben (in 1'000 CHF)",
             "y": "Umsatz (in 1'000 CHF)"
         }
-    elif dataset_choice_mult == "ðŸ  HÃ¤userpreise mit Pool (1000 HÃ¤user)":
+        descriptions["educational"] = "ðŸ’¡ **Vergleiche mit Einfacher Regression:** Dort fehlt eine Variable â†’ grÃ¶ÃŸerer Fehlerterm!"
+    elif "hÃ¤user" in dataset_lower or "haus" in dataset_lower or dataset_choice_mult == "houses":
         descriptions["main"] = "Eine Studie von **1000 HausverkÃ¤ufen** in einer UniversitÃ¤tsstadt untersucht den Einfluss von WohnflÃ¤che und Pool auf den Hauspreis."
         descriptions["variables"] = {
             "x1": "WohnflÃ¤che (sqft/10)",
             "x2": "Pool vorhanden (0/1)",
             "y": "Hauspreis (USD)"
         }
-    elif dataset_choice_mult == "ðŸ‡¨ðŸ‡­ Schweizer Kantone (sozioÃ¶konomisch)":
+        descriptions["educational"] = "ðŸ’¡ **Vergleiche mit Einfacher Regression:** Nur FlÃ¤che â†’ Pool-Effekt fehlt â†’ grÃ¶ÃŸerer Fehler!"
+    elif "kantone" in dataset_lower or "schweizer" in dataset_lower:
         descriptions["main"] = "**26 Schweizer Kantone** - Analyse des Zusammenhangs zwischen BevÃ¶lkerungsdichte, AuslÃ¤nderanteil, Arbeitslosigkeit und Wirtschaftskraft."
         descriptions["variables"] = {
             "x1": "BevÃ¶lkerungsdichte (pro kmÂ²)",
@@ -73,7 +90,7 @@ def get_multiple_regression_descriptions(dataset_choice_mult: str) -> Dict[str,
             "x3": "Arbeitslosenquote (%)",
             "y": "BIP pro Kopf (CHF)"
         }
-    elif dataset_choice_mult == "ðŸŒ¤ï¸ Schweizer Wetterstationen":
+    elif "wetter" in dataset_lower:
         descriptions["main"] = "**7 Schweizer Wetterstationen** von 273m bis 3576m HÃ¶he - Untersuchung der ZusammenhÃ¤nge zwischen geografischen Faktoren und Temperatur."
         descriptions["variables"] = {
             "x1": "HÃ¶he Ã¼ber Meer (m)",
@@ -81,13 +98,30 @@ def get_multiple_regression_descriptions(dataset_choice_mult: str) -> Dict[str,
             "x3": "Luftfeuchtigkeit (%)",
             "y": "Durchschnittstemperatur (Â°C)"
         }
-    else:  # Elektronikmarkt
+    elif "werbe" in dataset_lower or dataset_choice_mult == "advertising":
+        descriptions["main"] = "Eine Werbestudie analysiert den Zusammenhang zwischen **Werbeausgaben**, **ProduktqualitÃ¤t** und **Umsatz**."
+        descriptions["variables"] = {
+            "x1": "Werbeausgaben ($)",
+            "x2": "ProduktqualitÃ¤t (1-10)",
+            "y": "Umsatz ($)"
+        }
+        descriptions["educational"] = "ðŸ’¡ **Vergleiche mit Einfacher Regression:** Dort fehlt QualitÃ¤t â†’ grÃ¶ÃŸerer Fehlerterm!"
+    elif "eis" in dataset_lower or "temperature" in dataset_lower or dataset_choice_mult == "temperature":
+        descriptions["main"] = "Eine Eisdiele analysiert den **Eisverkauf** in AbhÃ¤ngigkeit von **Temperatur** und ob es ein **Wochenende** ist."
+        descriptions["variables"] = {
+            "x1": "Temperatur (Â°C)",
+            "x2": "Wochenende (0=Nein, 1=Ja)",
+            "y": "Eisverkauf (Einheiten)"
+        }
+        descriptions["educational"] = "ðŸ’¡ **Vergleiche mit Einfacher Regression:** Dort fehlt Wochenend-Effekt â†’ grÃ¶ÃŸerer Fehler!"
+    else:  # Elektronikmarkt (default)
         descriptions["main"] = "Eine Elektronikmarkt-Kette analysiert **50 Filialen** - Zusammenhang zwischen VerkaufsflÃ¤che, Marketingbudget und Umsatz."
         descriptions["variables"] = {
             "x1": "VerkaufsflÃ¤che (100 qm)",
             "x2": "Marketingbudget (1'000 â‚¬)",
             "y": "Umsatz (Mio. â‚¬)"
         }
+        descriptions["educational"] = "ðŸ’¡ **Vergleiche mit Einfacher Regression:** Dort fehlt Marketing â†’ grÃ¶ÃŸerer Fehlerterm!"
 
     return descriptions
 
@@ -100,6 +134,9 @@ def get_simple_regression_content(dataset_choice: str, x_variable: str) -> Dict[
     """
     Get all content for simple regression based on dataset and x_variable.
 
+    All datasets are available for simple regression to allow comparison
+    with multiple regression (educational: omitted variable bias).
+
     Args:
         dataset_choice: The selected dataset
         x_variable: The selected x variable
@@ -110,11 +147,19 @@ def get_simple_regression_content(dataset_choice: str, x_variable: str) -> Dict[
     Raises:
         ValueError: If dataset_choice or x_variable is invalid
     """
-    # Validate dataset_choice
+    # Validate dataset_choice - all datasets now available for educational purposes
     valid_datasets = [
         "ðŸª Elektronikmarkt (simuliert)",
         "ðŸ™ï¸ StÃ¤dte-Umsatzstudie (75 StÃ¤dte)",
-        "ðŸ‡¨ðŸ‡­ Schweizer Kantone (sozioÃ¶konomisch)"
+        "ðŸ  HÃ¤userpreise mit Pool (1000 HÃ¤user)",
+        "ðŸ‡¨ðŸ‡­ Schweizer Kantone (sozioÃ¶konomisch)",
+        "ðŸŒ¤ï¸ Schweizer Wetterstationen",
+        # Also accept simple IDs
+        "electronics",
+        "cities",
+        "houses",
+        "advertising",
+        "temperature"
     ]
 
     if dataset_choice not in valid_datasets:
@@ -314,16 +359,24 @@ def get_simple_regression_content(dataset_choice: str, x_variable: str) -> Dict[
             })
 
     # Validate x_variable for each dataset
-    if dataset_choice == "ðŸª Elektronikmarkt (simuliert)":
-        valid_variables = ["VerkaufsflÃ¤che (mÂ²)"]
-    elif dataset_choice == "ðŸ™ï¸ StÃ¤dte-Umsatzstudie (75 StÃ¤dte)":
-        valid_variables = ["Preis (CHF)", "Werbeausgaben (CHF)"]
+    # Note: "x1" and "x2" are always valid for API-style dataset names
+    if dataset_choice == "ðŸª Elektronikmarkt (simuliert)" or dataset_choice == "electronics":
+        valid_variables = ["VerkaufsflÃ¤che (mÂ²)", "x1"]
+    elif dataset_choice == "ðŸ™ï¸ StÃ¤dte-Umsatzstudie (75 StÃ¤dte)" or dataset_choice == "cities":
+        valid_variables = ["Preis (CHF)", "Werbeausgaben (CHF)", "x1", "x2"]
+    elif dataset_choice == "ðŸ  HÃ¤userpreise mit Pool (1000 HÃ¤user)" or dataset_choice == "houses":
+        valid_variables = ["WohnflÃ¤che (sqft/10)", "Pool (0/1)", "x1", "x2"]
     elif dataset_choice == "ðŸ‡¨ðŸ‡­ Schweizer Kantone (sozioÃ¶konomisch)":
-        valid_variables = ["Population Density", "Foreign Population %", "Unemployment"]
+        valid_variables = ["Population Density", "Foreign Population %", "Unemployment", "x1", "x2", "x3"]
     elif dataset_choice == "ðŸŒ¤ï¸ Schweizer Wetterstationen":
-        valid_variables = ["Altitude", "Sunshine Hours", "Humidity"]
+        valid_variables = ["Altitude", "Sunshine Hours", "Humidity", "x1", "x2", "x3"]
+    elif dataset_choice == "advertising":
+        valid_variables = ["Werbeausgaben ($)", "x1"]
+    elif dataset_choice == "temperature":
+        valid_variables = ["Temperatur (Â°C)", "x1"]
     else:
-        valid_variables = []
+        # Accept any x_variable for unknown datasets (flexible for new datasets)
+        valid_variables = [x_variable]
 
     if x_variable not in valid_variables:
         raise ValueError(f"Invalid x_variable '{x_variable}' for dataset '{dataset_choice}'. Valid options: {valid_variables}")
diff --git a/src/pipeline/get_data.py b/src/pipeline/get_data.py
index 50cbb41..a0556a1 100644
--- a/src/pipeline/get_data.py
+++ b/src/pipeline/get_data.py
@@ -82,22 +82,24 @@ def get_simple(
         seed: int = 42,
         true_intercept: float = 0.6,
         true_slope: float = 0.52,
+        x_variable: str = "x1",
     ) -> DataResult:
         """
         Get data for simple regression.
         
         Args:
-            dataset: Dataset name ("electronics", "advertising", "temperature")
+            dataset: Dataset name ("electronics", "advertising", "temperature", "cities", "houses")
             n: Number of observations
             noise: Noise level (standard deviation)
             seed: Random seed for reproducibility
             true_intercept: True Î²â‚€ (for simulated data)
             true_slope: True Î²â‚ (for simulated data)
+            x_variable: Which X variable to use ("x1" or "x2") for multi-variable datasets
         
         Returns:
             DataResult with x, y arrays and metadata
         """
-        logger.info(f"Fetching simple regression data: {dataset}, n={n}")
+        logger.info(f"Fetching simple regression data: {dataset}, n={n}, x_variable={x_variable}")
         np.random.seed(seed)
         
         if dataset == "electronics":
@@ -106,6 +108,10 @@ def get_simple(
             return self._generate_advertising(n, noise)
         elif dataset == "temperature":
             return self._generate_temperature(n, noise)
+        elif dataset == "cities":
+            return self._generate_cities_simple(n, noise, x_variable)
+        elif dataset == "houses":
+            return self._generate_houses_simple(n, noise, x_variable)
         else:
             # Default synthetic data
             return self._generate_synthetic(n, noise, true_intercept, true_slope)
@@ -121,7 +127,7 @@ def get_multiple(
         Get data for multiple regression.
         
         Args:
-            dataset: Dataset name ("cities", "houses")
+            dataset: Dataset name ("cities", "houses", "electronics", "advertising", "temperature")
             n: Number of observations
             noise: Noise level
             seed: Random seed
@@ -136,6 +142,12 @@ def get_multiple(
             return self._generate_cities(n, noise)
         elif dataset == "houses":
             return self._generate_houses(n, noise)
+        elif dataset == "electronics":
+            return self._generate_electronics_multiple(n, noise)
+        elif dataset == "advertising":
+            return self._generate_advertising_multiple(n, noise)
+        elif dataset == "temperature":
+            return self._generate_temperature_multiple(n, noise)
         else:
             return self._generate_cities(n, noise)
     
@@ -246,3 +258,214 @@ def _generate_houses(self, n: int, noise: float) -> MultipleRegressionDataResult
             y_label="Preis ($1000)",
             extra={"true_b0": 50, "true_b1": 8, "true_b2": 30}
         )
+    
+    # =========================================================
+    # Simple Regression versions of Multiple Regression datasets
+    # =========================================================
+    
+    def _generate_cities_simple(
+        self, n: int, noise: float, x_variable: str = "x1"
+    ) -> DataResult:
+        """
+        Generate cities data for SIMPLE regression (one variable only).
+        
+        Educational purpose: Shows larger error term when only using one predictor,
+        then students can compare with multiple regression to see improvement.
+        """
+        # Generate same underlying data as multiple regression
+        x1 = np.random.normal(5.69, 0.52, n)  # Preis
+        x1 = np.clip(x1, 4.5, 7.0)
+        
+        x2 = np.random.normal(1.84, 0.83, n)  # Werbung
+        x2 = np.clip(x2, 0.5, 3.5)
+        
+        # True model: y = 120 - 8*Preis + 4*Werbung + error
+        y = 120 - 8 * x1 + 4 * x2 + np.random.normal(0, noise, n)
+        
+        if x_variable == "x2":
+            # Nur Werbung â†’ Umsatz (Preis-Effekt wird ignoriert â†’ grÃ¶ÃŸerer Fehler!)
+            return DataResult(
+                x=x2, y=y,
+                x_label="Werbeausgaben (1000 CHF)",
+                y_label="Umsatz (1000 CHF)",
+                x_unit="1000 CHF",
+                y_unit="1000 CHF",
+                context_title="ðŸ™ï¸ StÃ¤dte-Studie: Nur Werbung",
+                context_description="""
+                **Einfache Regression:** Nur Werbeausgaben â†’ Umsatz
+                
+                âš ï¸ **Didaktisch wichtig:** Der Preis-Effekt wird NICHT berÃ¼cksichtigt!
+                â†’ GrÃ¶ÃŸerer Fehlerterm als bei multipler Regression.
+                
+                ðŸ’¡ Wechsle zu **Multipler Regression**, um zu sehen wie sich RÂ² verbessert!
+                """,
+                extra={"true_b1": 4, "omitted_variable": "Preis", "omitted_effect": -8}
+            )
+        else:
+            # Nur Preis â†’ Umsatz (Werbe-Effekt wird ignoriert â†’ grÃ¶ÃŸerer Fehler!)
+            return DataResult(
+                x=x1, y=y,
+                x_label="Preis (CHF)",
+                y_label="Umsatz (1000 CHF)",
+                x_unit="CHF",
+                y_unit="1000 CHF",
+                context_title="ðŸ™ï¸ StÃ¤dte-Studie: Nur Preis",
+                context_description="""
+                **Einfache Regression:** Nur Preis â†’ Umsatz
+                
+                âš ï¸ **Didaktisch wichtig:** Der Werbe-Effekt wird NICHT berÃ¼cksichtigt!
+                â†’ GrÃ¶ÃŸerer Fehlerterm als bei multipler Regression.
+                
+                ðŸ’¡ Wechsle zu **Multipler Regression**, um zu sehen wie sich RÂ² verbessert!
+                """,
+                extra={"true_b1": -8, "omitted_variable": "Werbung", "omitted_effect": 4}
+            )
+    
+    def _generate_houses_simple(
+        self, n: int, noise: float, x_variable: str = "x1"
+    ) -> DataResult:
+        """
+        Generate houses data for SIMPLE regression (one variable only).
+        
+        Educational purpose: Shows larger error term when only using one predictor.
+        """
+        # Generate same underlying data as multiple regression
+        x1 = np.random.normal(25.21, 2.92, n)  # WohnflÃ¤che
+        x1 = np.clip(x1, 18, 35)
+        
+        x2 = (np.random.random(n) < 0.204).astype(float)  # Pool
+        
+        # True model: y = 50 + 8*FlÃ¤che + 30*Pool + error
+        y = 50 + 8 * x1 + 30 * x2 + np.random.normal(0, noise, n)
+        
+        if x_variable == "x2":
+            # Nur Pool â†’ Preis (FlÃ¤chen-Effekt wird ignoriert â†’ grÃ¶ÃŸerer Fehler!)
+            return DataResult(
+                x=x2, y=y,
+                x_label="Pool (0/1)",
+                y_label="Preis ($1000)",
+                x_unit="0/1",
+                y_unit="$1000",
+                context_title="ðŸ  HÃ¤userpreise: Nur Pool",
+                context_description="""
+                **Einfache Regression:** Nur Pool â†’ Hauspreis
+                
+                âš ï¸ **Didaktisch wichtig:** Die WohnflÃ¤che wird NICHT berÃ¼cksichtigt!
+                â†’ GrÃ¶ÃŸerer Fehlerterm als bei multipler Regression.
+                
+                ðŸ’¡ Dies ist eine **Dummy-Variable** (0/1). Î²â‚ zeigt den Preisunterschied
+                zwischen HÃ¤usern MIT vs. OHNE Pool.
+                
+                âž¡ï¸ Wechsle zu **Multipler Regression** fÃ¼r bessere Vorhersage!
+                """,
+                extra={"true_b1": 30, "omitted_variable": "WohnflÃ¤che", "omitted_effect": 8}
+            )
+        else:
+            # Nur WohnflÃ¤che â†’ Preis (Pool-Effekt wird ignoriert â†’ grÃ¶ÃŸerer Fehler!)
+            return DataResult(
+                x=x1, y=y,
+                x_label="WohnflÃ¤che (sqft/10)",
+                y_label="Preis ($1000)",
+                x_unit="sqft/10",
+                y_unit="$1000",
+                context_title="ðŸ  HÃ¤userpreise: Nur FlÃ¤che",
+                context_description="""
+                **Einfache Regression:** Nur WohnflÃ¤che â†’ Hauspreis
+                
+                âš ï¸ **Didaktisch wichtig:** Der Pool-Effekt wird NICHT berÃ¼cksichtigt!
+                â†’ GrÃ¶ÃŸerer Fehlerterm als bei multipler Regression.
+                
+                ðŸ’¡ Wechsle zu **Multipler Regression**, um zu sehen wie sich RÂ² verbessert!
+                """,
+                extra={"true_b1": 8, "omitted_variable": "Pool", "omitted_effect": 30}
+            )
+    
+    # =========================================================
+    # Multiple Regression versions of Simple Regression datasets
+    # =========================================================
+    
+    def _generate_electronics_multiple(self, n: int, noise: float) -> MultipleRegressionDataResult:
+        """
+        Generate electronics data for MULTIPLE regression.
+        
+        Adds Marketing budget as second predictor.
+        Educational: Shows how RÂ² improves with additional relevant variable.
+        """
+        # VerkaufsflÃ¤che (100 qm)
+        x1 = np.random.uniform(2, 10, n)
+        
+        # Marketingbudget (1000 â‚¬) - korreliert leicht positiv mit FlÃ¤che
+        x2 = 0.3 * x1 + np.random.normal(2.5, 0.8, n)
+        x2 = np.clip(x2, 0.5, 5.0)
+        
+        # Umsatz = 0.6 + 0.52*FlÃ¤che + 0.35*Marketing + noise
+        y = 0.6 + 0.52 * x1 + 0.35 * x2 + np.random.normal(0, noise, n)
+        
+        return MultipleRegressionDataResult(
+            x1=x1, x2=x2, y=y,
+            x1_label="VerkaufsflÃ¤che (100 qm)",
+            x2_label="Marketingbudget (1000 â‚¬)",
+            y_label="Umsatz (Mio. â‚¬)",
+            extra={
+                "true_b0": 0.6, 
+                "true_b1": 0.52, 
+                "true_b2": 0.35,
+                "context": "Elektronikmarkt-Kette mit zwei PrÃ¤diktoren"
+            }
+        )
+    
+    def _generate_advertising_multiple(self, n: int, noise: float) -> MultipleRegressionDataResult:
+        """
+        Generate advertising data for MULTIPLE regression.
+        
+        Adds product quality rating as second predictor.
+        """
+        # Werbeausgaben ($)
+        x1 = np.random.uniform(1000, 10000, n)
+        
+        # ProduktqualitÃ¤ts-Rating (1-10)
+        x2 = np.random.uniform(4, 9, n)
+        
+        # Umsatz = 20000 + 5*Werbung + 8000*QualitÃ¤t + noise
+        y = 20000 + 5.0 * x1 + 8000 * x2 + np.random.normal(0, noise * 5000, n)
+        
+        return MultipleRegressionDataResult(
+            x1=x1, x2=x2, y=y,
+            x1_label="Werbeausgaben ($)",
+            x2_label="ProduktqualitÃ¤t (1-10)",
+            y_label="Umsatz ($)",
+            extra={
+                "true_b0": 20000, 
+                "true_b1": 5.0, 
+                "true_b2": 8000,
+                "context": "Werbestudie mit QualitÃ¤tsfaktor"
+            }
+        )
+    
+    def _generate_temperature_multiple(self, n: int, noise: float) -> MultipleRegressionDataResult:
+        """
+        Generate temperature/ice cream data for MULTIPLE regression.
+        
+        Adds weekend indicator as second predictor.
+        """
+        # Temperatur (Â°C)
+        x1 = np.random.uniform(15, 35, n)
+        
+        # Wochenende (0/1) - Dummy-Variable
+        x2 = (np.random.random(n) < 0.286).astype(float)  # ~2/7 sind Wochenende
+        
+        # Eisverkauf = 20 + 3*Temperatur + 25*Wochenende + noise
+        y = 20 + 3.0 * x1 + 25 * x2 + np.random.normal(0, noise * 10, n)
+        
+        return MultipleRegressionDataResult(
+            x1=x1, x2=x2, y=y,
+            x1_label="Temperatur (Â°C)",
+            x2_label="Wochenende (0/1)",
+            y_label="Eisverkauf (Einheiten)",
+            extra={
+                "true_b0": 20, 
+                "true_b1": 3.0, 
+                "true_b2": 25,
+                "context": "Eisverkauf mit Wochenend-Effekt"
+            }
+        )
